#include "utils/aes_core.h"
#include "utils/aes_host.h"
#include "utils/aes_mode.h"
#include "utils/aes_gcm.h"
#include "utils/safe_allocator.hpp"
#include <iomanip>

int main(int argc, char * argv[]) {
	// TODO MAIN WITH SOCKET WITH PRIVATE/PUBLIC KEYS + AES
	// Generate AES key and round keys
	/*crypto::safe_vector<uint8_t> aes_key = generate_aes_key(256);
	crypto::safe_vector<uint8_t> round_keys = key_schedule(aes_key);

	AES_CTR ctr;
	ctr.set_key(aes_key);
	std::array<uint8_t, 12> iv = {1,2,3,4,5,6,7,8,9,'a','b','c'};
	ctr.set_iv(iv);
	std::string pl = "Ciao mondo, daje roma";
	auto cipher = ctr.encrypt(pl);
	auto plain = ctr.decrypt(cipher);
	std::cout << plain << std::endl;*/
	
	crypto::safe_vector<uint8_t> aes_key = {
	0xae, 0x68, 0x52, 0xf8, 0x12, 0x10, 0x67, 0xcc,
	0x4b, 0xf7, 0xa5, 0x76, 0x55, 0x77, 0xf3, 0x9e
	};

	std::vector<uint8_t> iv = {
	0x00, 0x00, 0x00, 0x30,  // nonce (4 byte)
	0x00, 0x00, 0x00, 0x00,  // part of IV
	0x00, 0x00, 0x00, 0x00
	};

	// Plaintext
	std::string plaintext = "Ciao Mondo!!";

	AES_CTR ctr;
	ctr.set_key(aes_key);
	ctr.set_iv(iv);
	std::string ciphertext = ctr.encrypt(plaintext);
	std::string new_pl = ctr.decrypt(ciphertext);
	std::cout << new_pl << std::endl;


	AES_GCM gcm;
	aes_key = {
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};	
	iv = {
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
	};
	gcm.set_key(aes_key);
	gcm.set_iv(iv);
	std::vector<uint8_t> aad = {
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
	gcm.set_aad(aad);
	std::array<uint8_t, 16> H_ = gcm.compute_H0();
	for (auto byte : H_) {
		std::cout << std::hex << static_cast<int>(byte) << " ";
	}
	std::cout << std::endl;

	std::array<uint8_t, 16> H = {
	0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b,
	0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e
	};

	std::array<uint8_t, 16> X = {
		0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92,
		0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78
	};

	std::array<uint8_t, 16> expected = {
		0x5e, 0x2e, 0xc7, 0x46, 0x91, 0x70, 0x62, 0x88,
		0x2c, 0x85, 0xb0, 0x68, 0x53, 0x53, 0xde, 0xb7
	};

	std::array<uint8_t, 16> ciphertext_c = {
		0x03, 0x88, 0xda, 0xce,
		0x60, 0xb6, 0xa3, 0x92,
		0xf3, 0x28, 0xc2, 0xb9,
		0x71, 0xb2, 0xfe, 0x78
	};

	std::array<uint8_t, 16> Tag_expected = {
		0xab, 0x6e, 0x47, 0xd4, 0x2c, 0xec, 0x13, 0xbd,
		0xf5, 0x3a, 0x67, 0xb2, 0x12, 0x57, 0xbd, 0xdf
	};

	std::array<uint8_t, 16> AES_J0_encrypted = {
		0x58, 0xe2, 0xfc, 0xce,
		0xfa, 0x7e, 0x30, 0x61,
		0x36, 0x7f, 0x1d, 0x57,
		0xa4, 0xe7, 0x45, 0x5a
	};

	GHASH g;
	g.set_H(H);
	g.set_EJ0(AES_J0_encrypted);
	std::array<uint8_t, 16> hash = g.compute_ghash(ciphertext_c);
	std::array<uint8_t, 16> tag = g.compute_tag();
	for (auto byte : tag) {
		std::cout << std::hex << static_cast<int>(byte) << " ";
	}

	return 0;

}